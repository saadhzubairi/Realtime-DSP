===> combineAllPy.py
from pathlib import Path
from typing import List


def read_text_with_fallback(file_path: Path) -> str:
    """Read text using UTF-8, falling back to latin-1 if needed.

    Some demo files may contain characters not valid in UTF-8 on Windows.
    """
    try:
        return file_path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        return file_path.read_text(encoding="latin-1")


def find_python_files(root_dir: Path) -> List[Path]:
    """Return a sorted list of .py files under root_dir (recursively),
    excluding common transient directories like __pycache__.
    """
    all_py_files = [
        p for p in root_dir.rglob("*.py") if "__pycache__" not in p.parts
    ]
    # Sort by normalized POSIX-like path for stable, human-friendly ordering
    return sorted(all_py_files, key=lambda p: p.as_posix().lower())


def write_combined_text(root_dir: Path, py_files: List[Path], output_file: Path) -> None:
    """Write all files into a single text file with headers:

    ===> <relative_path>
    <file content>
    """
    output_file.parent.mkdir(parents=True, exist_ok=True)
    with output_file.open("w", encoding="utf-8") as out_f:
        for file_path in py_files:
            rel_path = file_path.relative_to(root_dir).as_posix()
            out_f.write(f"===> {rel_path}\n")
            content = read_text_with_fallback(file_path)
            out_f.write(content)
            if not content.endswith("\n"):
                out_f.write("\n")
            out_f.write("\n")  # blank line between files


def main() -> None:
    # Use the directory that contains this script as the root to search
    root_dir = Path(__file__).parent.resolve()
    output_file = root_dir / "all_python_files_combined.txt"

    py_files = find_python_files(root_dir)
    write_combined_text(root_dir, py_files, output_file)
    print(f"Wrote {len(py_files)} files to {output_file}")


if __name__ == "__main__":
    main()



===> myfunctions.py

def clip16( x ):    
    # Clipping for 16 bits
    if x > 32767:
        x = 32767
    elif x < -32768:
        x = -32768
    else:
        x = x        
    return (x)


===> prog_A1.py
# plot_wave_file_using_animate

import wave
import struct
import matplotlib
from matplotlib import pyplot
from matplotlib import animation

matplotlib.use('TkAgg')
# matplotlib.use('MacOSX')

print('The matplotlib backend is %s' % pyplot.get_backend())      # Plotting backend

# Specify wave file
wavfile = 'author.wav'
print('Name of wave file: %s' % wavfile)

# Open wave file
wf = wave.open( wavfile, 'rb')

# Read wave file properties
RATE        = wf.getframerate()     # Frame rate (frames/second)
WIDTH       = wf.getsampwidth()     # Number of bytes per sample
LEN         = wf.getnframes()       # Signal length
CHANNELS    = wf.getnchannels()     # Number of channels

print('The file has %d channel(s).'         % CHANNELS)
print('The file has %d frames/second.'      % RATE)
print('The file has %d frames.'             % LEN)
print('The file has %d bytes per sample.'   % WIDTH)

BLOCKLEN = 500    # Blocksize

# Set up plotting...

fig1 = pyplot.figure(1)
ax1 = fig1.add_subplot(1, 1, 1)   # axes
[g1] = ax1.plot([], [])

# Define animation functions

def my_init():
    g1.set_xdata(range(BLOCKLEN))
    ax1.set_ylim(-32000, 32000)
    ax1.set_xlim(0, BLOCKLEN)
    return (g1,)

def my_update(i):

    # print(i)

    # Get block of samples from wave file
    input_bytes = wf.readframes(BLOCKLEN)

    # Convert binary data to sequence (tuple) of numbers
    signal_block = struct.unpack('h' * BLOCKLEN, input_bytes)

    # Update plot
    g1.set_ydata(signal_block)

    return (g1,)

Nplots = int(LEN/BLOCKLEN) - 1
print('Number of plots = ', Nplots)

my_anima = animation.FuncAnimation(
    fig1,
    my_update,
    frames = Nplots,
    init_func = my_init,
    interval = 50,   # milliseconds   # Try 5 and 100 and re-run
    blit = True,
    repeat = False
)
pyplot.show()   # Needed for FuncAnimation to show plots

pyplot.close()
wf.close()

print('* Finished')



===> prog_A2.py
# plot_file_with_animate_numpy_spectrum.py

import wave
import matplotlib
from matplotlib import pyplot
from matplotlib import animation
import numpy as np

matplotlib.use('TkAgg')
# matplotlib.use('MacOSX')

print('The matplotlib backend is %s' % pyplot.get_backend())      # Plotting backend

# Specify wave file
wavfile = 'author.wav'
# wavfile = 'sines.wav'
print('Name of wave file: %s' % wavfile)

# Open wave file
wf = wave.open( wavfile, 'rb')

# Read wave file properties
RATE        = wf.getframerate()     # Frame rate (frames/second)
WIDTH       = wf.getsampwidth()     # Number of bytes per sample
LEN         = wf.getnframes()       # Signal length
CHANNELS    = wf.getnchannels()     # Number of channels

print('The file has %d channel(s).'         % CHANNELS)
print('The file has %d frames/second.'      % RATE)
print('The file has %d frames.'             % LEN)
print('The file has %d bytes per sample.'   % WIDTH)

BLOCKLEN = 256
# BLOCKLEN = 128
# BLOCKLEN = 64
# BLOCKLEN = 32
# BLOCKLEN = 8

BLOCK_DURATION = 1000.0 * BLOCKLEN/RATE # duration in milliseconds
print('Block length: %d' % BLOCKLEN)
print('Duration of block in milliseconds: %.2f' % BLOCK_DURATION)

# Set up for plotting

fig1 = pyplot.figure(1)
fig1.set_size_inches((5, 6))  # (width, height)

ax_x = fig1.add_subplot(2, 1, 1)
ax_X = fig1.add_subplot(2, 1, 2)

x = np.zeros(BLOCKLEN)              # signal
X = np.fft.rfft(x)                  # frequency spectrum of signal (real fft)

n = np.arange(BLOCKLEN)             # Time axis
f_X = np.arange(X.size) / BLOCKLEN  # frequency axis (normalized frequency)

# signal plot
[g_x] = ax_x.plot([], [])
ax_x.set_ylim(-32000, 32000)
ax_x.set_xlim(0, BLOCKLEN)
ax_x.set_xlabel('Time (index)')
ax_x.set_title('Signal')

# Frequency spectrum plot
[g_X] = ax_X.plot([], [])
ax_X.set_xlim(0, 0.5)
ax_X.set_ylim(0, 5000)
ax_X.set_title('Frequency spectrum')
ax_X.set_xlabel('Frequency (cycles/sample)')

fig1.tight_layout()


# Define animation functions

def my_init():
    g_x.set_xdata(n)
    g_X.set_xdata(f_X)
    return (g_x, g_X)

def my_update(i):

    global states

    # Get block of samples from wave file
    signal_bytes = wf.readframes(BLOCKLEN)

    # Convert binary data to number sequence (numpy array)
    x = np.frombuffer(signal_bytes, dtype = 'int16')

    # Compute frequency spectrum
    X = np.fft.rfft(x) / BLOCKLEN

    # Update graphs
    g_x.set_ydata(x)
    g_X.set_ydata(np.abs(X))

    return (g_x, g_X)

Num_Plots = int(LEN/BLOCKLEN) - 1
print('Number of plots = ', Num_Plots)

my_anima = animation.FuncAnimation(
    fig1,
    my_update,
    init_func = my_init,
    frames = Num_Plots,
    # interval = ..,   # milliseconds 
    interval = 5 * BLOCK_DURATION,  # plot slower than real time
    blit = True,
    repeat = False
)
pyplot.show()   # Needed for FuncAnimation to show plots

wf.close()

print('* Finished')



===> prog_A3.py
# plot_file_with_animate_numpy_filter.py

import wave
import matplotlib
from matplotlib import pyplot
from matplotlib import animation
import numpy as np
from scipy.signal import butter, lfilter, freqz

matplotlib.use('TkAgg')
# matplotlib.use('MacOSX')

print('The matplotlib backend is %s' % pyplot.get_backend())      # Plotting backend

# Specify wave file
wavfile = 'author.wav'
# wavfile = 'sines.wav'
print('Name of wave file: %s' % wavfile)

# Open wave file
wf = wave.open( wavfile, 'rb')

# Read wave file properties
RATE        = wf.getframerate()     # Frame rate (frames/second)
WIDTH       = wf.getsampwidth()     # Number of bytes per sample
LEN         = wf.getnframes()       # Signal length
CHANNELS    = wf.getnchannels()     # Number of channels

print('The file has %d channel(s).'         % CHANNELS)
print('The file has %d frames/second.'      % RATE)
print('The file has %d frames.'             % LEN)
print('The file has %d bytes per sample.'   % WIDTH)

BLOCKLEN = 256
# BLOCKLEN = 128
# BLOCKLEN = 64
# BLOCKLEN = 32
# BLOCKLEN = 8

BLOCK_DURATION = 1000.0 * BLOCKLEN/RATE # duration in milliseconds
print('Block length: %d' % BLOCKLEN)
print('Duration of block in milliseconds: %.2f' % BLOCK_DURATION)


# Create Butterworth filter

ORDER = 3   # filter order
fc = 0.05
# [b, a] = butter(ORDER, 2 * fc)
[b, a] = butter(ORDER, 2 * fc, btype = 'high')
[om, H] = freqz(b, a)
f = om/(2 * np.pi) * RATE
states = np.zeros(ORDER)

# Create figure, ...

fig1 = pyplot.figure(1)
fig1.set_size_inches((6, 8))  # (width, height)

ax_x = fig1.add_subplot(3, 1, 1)
ax_H = fig1.add_subplot(3, 1, 2)
ax_y = fig1.add_subplot(3, 1, 3)

# Input signal plot
[g_x] = ax_x.plot([], [])
ax_x.set_ylim(-32000, 32000)
ax_x.set_xlim(0, 1000 * BLOCKLEN / RATE)
ax_x.set_xlabel('Time (msec)')
ax_x.set_title('Input signal')

# Frequency response plot
[g_H] = ax_H.plot(f, np.abs(H))
ax_H.set_xlim(0, RATE / 2)
ax_H.set_ylim(0, 1.2)
ax_H.set_title('Frequency response')
ax_H.set_xlabel('Frequency (Hz)')

# Output signal plot
[g_y] = ax_y.plot([], [])
ax_y.set_ylim(-32000, 32000)
ax_y.set_xlim(0, 1000 * BLOCKLEN / RATE)
ax_y.set_xlabel('Time (msec)')
ax_y.set_title('Output signal')

fig1.tight_layout()


# Define animation functions

def my_init():
    t = np.arange(BLOCKLEN) * (1000/RATE)   # time axis (milliseconds)
    g_x.set_xdata(t)
    g_y.set_xdata(t)
    return (g_x, g_y)

def my_update(i):

    global states

    # Get block of samples from wave file
    input_bytes = wf.readframes(BLOCKLEN)

    # Convert binary data to number sequence (numpy array)
    x = np.frombuffer(input_bytes, dtype = 'int16')

    [y, states] = lfilter(b, a, x, zi = states)

    # Update graphs
    g_x.set_ydata(x)
    g_y.set_ydata(y)

    return (g_x, g_y)

Num_Plots = int(LEN/BLOCKLEN) - 1
print('Number of plots = ', Num_Plots)

my_anima = animation.FuncAnimation(
    fig1,
    my_update,
    frames = Num_Plots,
    init_func = my_init,
    # interval = ...,   # milliseconds
    # interval = BLOCK_DURATION,  # plot at real time according to signal sampling rate
    interval = 5 * BLOCK_DURATION,  # plot slower than real time
    # interval = int(0.1*BLOCK_DURATION),  # plot faster than real time
    blit = True,
    repeat = False
)
pyplot.show()   # Needed for FuncAnimation to show plots

wf.close()

print('* Finished')

===> prog_A4.py
# plot_file_with_animate_numpy_filter_spectrum.py

import wave
import matplotlib
from matplotlib import pyplot
from matplotlib import animation
import numpy as np
from scipy.signal import butter, lfilter, freqz

# matplotlib.use('TkAgg')
matplotlib.use('MacOSX')

print('The matplotlib backend is %s' % pyplot.get_backend())      # Plotting backend

# Specify wave file (uncomment one of the following)
wavfile = 'author.wav'
# wavfile = 'sines.wav'
print('Name of wave file: %s' % wavfile)

# Open wave file
wf = wave.open( wavfile, 'rb')

# Read wave file properties
RATE        = wf.getframerate()     # Frame rate (frames/second)
WIDTH       = wf.getsampwidth()     # Number of bytes per sample
LEN         = wf.getnframes()       # Signal length
CHANNELS    = wf.getnchannels()     # Number of channels

print('The file has %d channel(s).'         % CHANNELS)
print('The file has %d frames/second.'      % RATE)
print('The file has %d frames.'             % LEN)
print('The file has %d bytes per sample.'   % WIDTH)

BLOCKLEN = 512
# BLOCKLEN = 256
# BLOCKLEN = 128
# BLOCKLEN = 64
# BLOCKLEN = 32
# BLOCKLEN = 8

BLOCK_DURATION = 1000.0 * BLOCKLEN/RATE # duration in milliseconds
print('Block length: %d' % BLOCKLEN)
print('Duration of block in milliseconds: %.2f' % BLOCK_DURATION)


# Create Butterworth filter

ORDER = 3   # filter order
fc = 0.1
# [b, a] = butter(ORDER, 2 * fc) # low-pass filter
[b, a] = butter(ORDER, 2 * fc, btype = 'high')    # high-pass filter
[om, H] = freqz(b, a)
f_H = om/(2 * np.pi) * RATE
states = np.zeros(ORDER)

# Create figure, ...

fig1 = pyplot.figure(1)
fig1.set_size_inches((12, 7))  # (width, height)

ax_x = fig1.add_subplot(2, 2, 1)
ax_X = fig1.add_subplot(2, 2, 2)
ax_y = fig1.add_subplot(2, 2, 3)
ax_Y = fig1.add_subplot(2, 2, 4)

x = np.zeros(BLOCKLEN)               # signal
X = np.fft.rfft(x)                   # spectrum of signal (real fft)
f_X = np.arange(X.size) * RATE / BLOCKLEN   # frequency axis (Hz)

# Input signal plot
[g_x] = ax_x.plot([], [])
ax_x.set_ylim(-32000, 32000)
ax_x.set_xlim(0, 1000 * BLOCKLEN / RATE)
ax_x.set_xlabel('Time (msec)')
ax_x.set_title('Input signal')

# Input spectrum plot
[g_X] = ax_X.plot([], [])
[g_H] = ax_X.plot(f_H, 500 * np.abs(H), label = 'Frequency response (x500)', color = 'green')
ax_X.set_xlim(0, RATE/2)
ax_X.set_ylim(0, 1000)
ax_X.set_title('Spectrum of input signal')
ax_X.set_xlabel('Frequency (Hz)')
ax_X.legend()

# Output signal plot
[g_y] = ax_y.plot([], [])
ax_y.set_ylim(-32000, 32000)
ax_y.set_xlim(0, 1000 * BLOCKLEN/RATE)
ax_y.set_xlabel('Time (milliseconds)')
ax_y.set_title('Output signal')

# Output spectrum plot
[g_Y] = ax_Y.plot([], [])
ax_Y.set_xlim(0, RATE/2)
ax_Y.set_ylim(0, 1000)
ax_Y.set_title('Spectrum of output signal')
ax_Y.set_xlabel('Frequency (Hz)')

fig1.tight_layout()


# Define animation functions

def my_init():
    t = np.arange(BLOCKLEN) * (1000/RATE)   # time axis (milliseconds)
    g_x.set_xdata( t )
    g_x.set_ydata( x )
    g_y.set_xdata( t )
    g_y.set_ydata( x )
    g_X.set_xdata( f_X )
    g_X.set_ydata( np.abs(X) )
    g_Y.set_xdata(f_X)
    g_Y.set_ydata( np.abs(X) )
    return (g_x, g_y, g_X, g_Y)

def my_update(i):

    global states

    # Get block of samples from wave file
    input_bytes = wf.readframes(BLOCKLEN)

    # Rewind if at end of file
    if len(input_bytes) < WIDTH * BLOCKLEN:
        wf.rewind()
        input_bytes = wf.readframes(BLOCKLEN)

    # Convert binary data to number sequence (numpy array)
    x = np.frombuffer(input_bytes, dtype = 'int16')

    [y, states] = lfilter(b, a, x, zi = states)

    # Compute frequency spectra
    X = np.fft.rfft(x) / BLOCKLEN
    Y = np.fft.rfft(y) / BLOCKLEN

    # Update graphs
    g_x.set_ydata(x)
    g_y.set_ydata(y)
    g_X.set_ydata( np.abs(X) )
    g_Y.set_ydata( np.abs(Y) )

    return (g_x, g_y, g_X, g_Y)


Num_Plots = int(LEN/BLOCKLEN) - 1
print('Number of plots = ', Num_Plots)

my_anima = animation.FuncAnimation(
    fig1,
    my_update,
    init_func = my_init,
    frames = Num_Plots,
    # interval = ...,   # milliseconds
    # interval = BLOCK_DURATION,  # plot at real time according to signal sampling rate
    interval = 5*BLOCK_DURATION,  # plot slower than real time
    blit = True,
    repeat = False
)
pyplot.show()   # Needed for FuncAnimation to show plots

wf.close()

print('* Finished')

===> prog_B1.py
# plot_file_using_animate_rolling.py

import struct
import wave
import matplotlib
from matplotlib import pyplot
from matplotlib.animation import FuncAnimation

# matplotlib.use('TkAgg')
# matplotlib.use('MacOSX')

print('The matplotlib backend is %s' % pyplot.get_backend())      # Plotting backend

# Specify wave file
wavfile = 'author.wav'
print('Name of wave file: %s' % wavfile)

# Open wave file
wf = wave.open( wavfile, 'rb')

# Read wave file properties
RATE        = wf.getframerate()     # Frame rate (frames/second)
WIDTH       = wf.getsampwidth()     # Number of bytes per sample
LEN         = wf.getnframes()       # Signal length
CHANNELS    = wf.getnchannels()     # Number of channels

print('The file has %d channel(s).'         % CHANNELS)
print('The file has %d frames/second.'      % RATE)
print('The file has %d frames.'             % LEN)
print('The file has %d bytes per sample.'   % WIDTH)

# Number of samples to read at a time
READ_LEN = 20

# Number of samples to plot
PLOT_LEN = 500

plot_block = PLOT_LEN * [0]

# Set up plotting...

fig1 = pyplot.figure(1)
ax1 = fig1.add_subplot(1, 1, 1)   # axes
[g1] = ax1.plot([], [])

def my_init():
    print('Initialize')
    g1.set_xdata(range(PLOT_LEN))
    g1.set_ydata(plot_block)
    ax1.set_ylim(-32000, 32000)
    ax1.set_xlim(0, PLOT_LEN)
    ax1.set_xlabel('Time (index)')
    ax1.set_title('Signal')
    return (g1,)

def my_update(i):

    global plot_block
    
    # Get block of samples from wave file
    input_bytes = wf.readframes(READ_LEN)

    # Convert binary data to sequence (tuple) of numbers
    read_block = struct.unpack('h' * READ_LEN, input_bytes)

    # Concatenate past signal values with new signal values
    plot_block = plot_block[READ_LEN:] + list(read_block)
    
    # Update plot
    g1.set_ydata(plot_block)

    return (g1,)

Num_Plots = int(LEN/READ_LEN) - 1
print('Number of plots = ', Num_Plots)

my_anima = FuncAnimation(
    fig1,
    my_update,
    frames = Num_Plots,
    init_func = my_init,
    interval = 20,   # milliseconds
    blit = True,
    repeat = False
)
pyplot.show()   # Needed for FuncAnimation to show plots

pyplot.close()
wf.close()

print('* Finished')


